import asyncio
import os
import logging
from functools import lru_cache
from threading import Lock
from typing import Dict, Any

from numpy import add, subtract, array  # type: ignore

from opentrons import commands, drivers
from opentrons.commands import CommandPublisher

from opentrons.data_storage import database, old_container_loading,\
    database_migration
from opentrons.drivers.smoothie_drivers import driver_3_0
from opentrons.drivers.types import MoveSplit
from opentrons.trackers import pose_tracker
from opentrons.config import feature_flags as fflags
from opentrons.config.robot_configs import load
from opentrons.legacy_api import containers, modules
from opentrons.legacy_api.containers import Container, load_new_labware,\
    save_new_offsets, load_new_labware_def
from opentrons.util.vector import Vector

from .mover import Mover
from opentrons.config import pipette_config


log = logging.getLogger(__name__)

TIP_CLEARANCE_DECK = 20    # clearance when moving between different labware
TIP_CLEARANCE_LABWARE = 5  # clearance when staying within a single labware


def _load_weird_container(container_name):
    """ Load a container from persisted containers, whatever that is """
    # First must populate "get persisted container" list
    old_container_loading.load_all_containers_from_disk()
    # Load container from old json file
    container = old_container_loading.get_persisted_container(
        container_name)
    # Rotate coordinates to fit the new deck map
    rotated_container = database_migration.rotate_container_for_alpha(
        container)
    # Save to the new database
    database.save_new_container(rotated_container, container_name)
    return container


def _load_container_by_name(container_name, version=None):
    """ Try and find a container in a variety of methods.

    Returns the container or raises a KeyError if it could not be found
    """
    for meth in (database.load_container,  # From the labware database
                 _load_weird_container):   # honestly don't know
        log.debug(
            f"Trying to load container {container_name} via {meth.__name__}")
        try:
            container = meth(container_name)
            if meth == _load_weird_container:
                container.properties['type'] = container_name
            log.info(f"Loaded {container_name} from {meth.__name__}")
            break
        except (ValueError, KeyError) as e:
            log.debug(f"{container_name} not in {meth.__name__} ({repr(e)})")
    else:
        log.debug(
            f"Trying to load container {container_name} version {version}"
            f"from v2 labware store")
        container = load_new_labware(container_name, version=version)
    return container


def _setup_container(container_obj):
    """ Fix up a loaded container's coordinates. Returns the container  """
    container_x, container_y, container_z = container_obj._coordinates

    # infer z from height
    if container_z == 0 and 'height' in container_obj[0].properties:
        container_z = container_obj[0].properties['height']

    container_obj._coordinates = Vector(
        container_x,
        container_y,
        container_z)

    return container_obj


class Robot(CommandPublisher):
    """
    This class is the main interface to the robot.

    It should never be instantiated directly; instead, the global instance may
    be accessed at :py:attr:`opentrons.robot`.

    Through this class you can can:
        * define your :class:`opentrons.Deck`
        * :meth:`connect` to Opentrons physical robot
        * :meth:`home` axis, move head (:meth:`move_to`)
        * :meth:`pause` and :func:`resume` the protocol run
        * set the :meth:`head_speed` of the robot

    Each Opentrons protocol is a Python script. When evaluated the script
    creates an execution plan which is stored as a list of commands in
    Robot's command queue.

    Here are the typical steps of writing the protocol:
        * Using a Python script and the Opentrons API load your
          containers and define instruments
          (see :class:`~opentrons.instruments.pipette.Pipette`).
        * Call :meth:`reset` to reset the robot's state and clear commands.
        * Write your instructions which will get converted
          into an execution plan.
        * Review the list of commands generated by a protocol
          :meth:`commands`.
        * :meth:`connect` to the robot and call :func:`run` it on a real robot.

    See :class:`Pipette` for the list of supported instructions.
    """

    def __init__(self, config=None, broker=None):
        """
        Initializes a robot instance.

        Notes
        -----
        This class is a singleton. That means every time you call
        :func:`__init__` the same instance will be returned. There's
        only once instance of a robot.
        """
        super().__init__(broker)
        self.config = config or load()
        self._driver = driver_3_0.SmoothieDriver_3_0_0(
            config=self.config)
        self._attached_modules: Dict[str, Any] = {}  # key is port + model
        self.fw_version = self._driver.get_fw_version()

        self.INSTRUMENT_DRIVERS_CACHE = {}
        self._instruments = {}
        self.model_by_mount = {
            'left': {'model': None, 'id': None, 'name': None,
                     'home_current': self.config.high_current['B']},
            'right': {'model': None, 'id': None, 'name': None,
                      'home_current': self.config.high_current['C']}
        }

        self._commands = []
        self._unsubscribe_commands = None
        self._smoothie_lock = Lock()
        self._gantry_cal_id = None
        self.reset()

    def __del__(self):
        if getattr(self, '_unsubscribe_commands', None):
            self._unsubscribe_commands()

    def _get_placement_location(self, placement):
        location = None
        # If `placement` is a string, assume it is a slot
        if isinstance(placement, str):
            location = self._deck[placement]
        elif getattr(placement, 'stackable', False):
            location = placement

        # Look for any module placed in the given slot
        # If there is, then the labware will be placed on the module
        module = location.get_module()
        return location if not module else module

    def _is_available_slot(self, location, share, slot, container_name):
        if pose_tracker.has_children(self.poses, location) and not share:
            raise RuntimeWarning(
                'Slot {0} has child. Use "containers.load(\'{1}\', \'{2}\', share=True)"'.format(  # NOQA
                    slot, container_name, slot))
        else:
            return True

    def clear_tips(self):
        """
        If reset is called with a tip attached, the tip must be removed
        before the poses and _instruments members are cleared. If the tip is
        not removed, the effective length of the pipette remains increased by
        the length of the tip, and subsequent `_add_tip` calls will increase
        the length in addition to this. This should be fixed by changing pose
        tracking to that it tracks the tip as a separate node rather than
        adding and subtracting the tip length to the pipette length.
        """
        for instrument in self._instruments.values():
            if instrument.tip_attached:
                instrument._remove_tip(instrument._tip_length)

    def reset(self):
        """
        Resets the state of the robot and clears:
            * Deck
            * Instruments
            * Command queue
            * Runtime warnings

        Examples
        --------

        >>> from opentrons import robot # doctest: +SKIP
        >>> robot.reset() # doctest: +SKIP
        """
        self._gantry_cal_id = id(self.config.gantry_calibration)
        self._actuators = {
            'left': {
                'carriage': Mover(
                    driver=self._driver,
                    src=pose_tracker.ROOT,
                    dst=self._gantry_cal_id,
                    axis_mapping={'z': 'Z'}),
                'plunger': Mover(
                    driver=self._driver,
                    src=pose_tracker.ROOT,
                    dst='volume-calibration-left',
                    axis_mapping={'x': 'B'})
            },
            'right': {
                'carriage': Mover(
                    driver=self._driver,
                    src=pose_tracker.ROOT,
                    dst=self._gantry_cal_id,
                    axis_mapping={'z': 'A'}),
                'plunger': Mover(
                    driver=self._driver,
                    src=pose_tracker.ROOT,
                    dst='volume-calibration-right',
                    axis_mapping={'x': 'C'})
            }
        }
        self.clear_tips()

        self.poses = pose_tracker.init()

        self._runtime_warnings = []

        self._deck = containers.Deck()
        self._fixed_trash = None
        self.setup_deck()
        self.setup_gantry()
        self._instruments = {}

        self._use_safest_height = False

        self._previous_instrument = None
        self._prev_container = None

        # TODO: Move homing info to driver
        self.axis_homed = {
            'x': False, 'y': False, 'z': False, 'a': False, 'b': False}

        self.clear_commands()

        # update the position of each Mover
        self._driver.update_position()
        for mount in self._actuators.values():
            for mover in mount.values():
                self.poses = mover.update_pose_from_driver(self.poses)
        self.cache_instrument_models()

        return self

    def cache_instrument_models(self):
        """
        Queries Smoothie for the model and ID strings of attached pipettes, and
        saves them so they can be reported without querying Smoothie again (as
        this could interrupt a command if done during a run or other movement).

        Shape of return dict should be:

        ```
        {
          "left": {
            "model": "<model_string>" or None,
            "id": "<pipette_id_string>" or None
          },
          "right": {
            "model": "<model_string>" or None,
            "id": "<pipette_id_string>" or None
          }
        }
        ```

        :return: a dict with pipette data (shape described above)
        """
        log.debug("Updating instrument model cache")
        for mount in self.model_by_mount.keys():
            plunger_axis = 'B' if mount == 'left' else 'C'
            mount_axis = 'Z' if mount == 'left' else 'A'
            model_value = self._driver.read_pipette_model(mount)
            splits = {plunger_axis: None}
            if model_value:
                name_value = pipette_config.name_for_model(model_value)
                pc = pipette_config.load(model_value)
                home_current = pc.plunger_current
                if 'needsUnstick' in pc.quirks:
                    splits[plunger_axis] = MoveSplit(split_distance=1,
                                                     split_current=1.5,
                                                     split_speed=1,
                                                     after_time=1800,
                                                     fullstep=True)
            else:
                name_value = None
                home_current = self.config.high_current[plunger_axis]

            if model_value:
                cfg = pipette_config.load(model_value)
                home_pos = cfg.home_position
                max_travel = cfg.max_travel
                steps_mm = cfg.steps_per_mm
                idle_current = cfg.idle_current
            else:
                home_pos = self.config.default_pipette_configs['homePosition']
                max_travel = self.config.default_pipette_configs['maxTravel']
                steps_mm = self.config.default_pipette_configs['stepsPerMM']
                idle_current = self.config.low_current[plunger_axis]

            self._driver.update_steps_per_mm({plunger_axis: steps_mm})
            self._driver.update_pipette_config(mount_axis, {'home': home_pos})
            self._driver.update_pipette_config(
                plunger_axis, {'max_travel': max_travel})
            self._driver.set_dwelling_current({plunger_axis: idle_current})
            self._driver.configure_splits_for(splits)

            if model_value:
                id_response = self._driver.read_pipette_id(mount)
            else:
                id_response = None
            self.model_by_mount[mount] = {
                'model': model_value,
                'id': id_response,
                'name': name_value,
                'home_current': home_current
            }
            log.debug("{}: {} [{}]".format(
                mount,
                self.model_by_mount[mount]['model'],
                self.model_by_mount[mount]['id']))

    def turn_on_button_light(self):
        self._driver.turn_on_blue_button_light()

    def turn_off_button_light(self):
        self._driver.turn_off_button_light()

    def turn_on_rail_lights(self):
        self._driver.turn_on_rail_lights()

    def turn_off_rail_lights(self):
        self._driver.turn_off_rail_lights()

    def get_rail_lights_on(self):
        return self._driver.get_rail_lights_on()

    def get_lights(self):
        return self._driver.get_lights()

    def set_lights(self, button=None, rails=None):
        self._driver.set_lights(button=button, rails=rails)

    def identify(self, seconds):
        """
        Identify a robot by flashing the light around the frame button for 10s
        """
        from time import sleep
        for i in range(seconds):
            self.turn_off_button_light()
            sleep(0.25)
            self.turn_on_button_light()
            sleep(0.25)

    def setup_gantry(self):
        driver = self._driver

        left_carriage = self._actuators['left']['carriage']
        right_carriage = self._actuators['right']['carriage']

        left_plunger = self._actuators['left']['plunger']
        right_plunger = self._actuators['right']['plunger']

        self.gantry = Mover(
            driver=driver,
            axis_mapping={'x': 'X', 'y': 'Y'},
            src=pose_tracker.ROOT,
            dst=self._gantry_cal_id
        )

        # Extract only transformation component
        inverse_transform = pose_tracker.inverse(
            pose_tracker.extract_transform(self.config.gantry_calibration))

        self.poses = pose_tracker.bind(self.poses) \
            .add(
                obj=self._gantry_cal_id,
                transform=self.config.gantry_calibration) \
            .add(obj=self.gantry, parent=self._gantry_cal_id) \
            .add(obj=left_carriage, parent=self.gantry) \
            .add(obj=right_carriage, parent=self.gantry) \
            .add(
                obj='left',
                parent=left_carriage,
                transform=inverse_transform) \
            .add(
                obj='right',
                parent=right_carriage,
                transform=inverse_transform) \
            .add(obj='volume-calibration-left') \
            .add(obj='volume-calibration-right') \
            .add(obj=left_plunger, parent='volume-calibration-left') \
            .add(obj=right_plunger, parent='volume-calibration-right')

    def add_instrument(self, mount, instrument):
        """
        Adds instrument to a robot.

        Parameters
        ----------
        mount : str
            Specifies which axis the instruments is attached to.
            Valid options are "left" or "right".
        instrument : Instrument
            An instance of a :class:`Pipette` to attached to the axis.

        Notes
        -----
        A canonical way to add to add a Pipette to a robot is:

        ::

            from opentrons import instruments
            m300 = instruments.P300_Multi(mount='left')

        This will create a pipette and call :func:`add_instrument`
        to attach the instrument.
        """
        if mount in self._instruments:
            prev_instr = self._instruments[mount]
            raise RuntimeError('Instrument {0} already on {1} mount'.format(
                prev_instr.name, mount))
        self._instruments[mount] = instrument

        instrument.instrument_actuator = self._actuators[mount]['plunger']
        instrument.instrument_mover = self._actuators[mount]['carriage']

        # instrument_offset is the distance found (with tip-probe) between
        # the pipette's expected position, and the actual position
        # this is expected to be no greater than ~3mm
        # Z is not included, because Z offsets found during tip-probe are used
        # to determined the tip's length
        cx, cy, _ = self.config.instrument_offset[mount][instrument.type]

        # model_offset is the expected position of the pipette, determined
        # by designed dimensions of that model (eg: p10-multi vs p300-single)
        mx, my, mz = instrument.model_offset

        # combine each offset to get the pipette's position relative to gantry
        _x, _y, _z = (
            mx + cx,
            my + cy,
            mz
        )
        # if it's the left mount, apply the offset from right pipette
        if mount == 'left':
            _x, _y, _z = (
               _x + self.config.mount_offset[0],
               _y + self.config.mount_offset[1],
               _z + self.config.mount_offset[2]
            )
        self.poses = pose_tracker.add(
            self.poses,
            instrument,
            parent=mount,
            point=(_x, _y, _z)
        )

    def remove_instrument(self, mount):
        instrument = self._instruments.pop(mount, None)
        if instrument:
            self.poses = pose_tracker.remove(self.poses, instrument)
        self.cache_instrument_models()

    def add_warning(self, warning_msg):
        """
        Internal. Add a runtime warning to the queue.
        """
        self._runtime_warnings.append(warning_msg)

    def get_warnings(self):
        """
        Get current runtime warnings.

        Returns
        -------

        Runtime warnings accumulated since the last :func:`run`
        or :func:`simulate`.
        """
        return list(self._runtime_warnings)

    def connect(self, port=None, options=None):
        """
        Connects the robot to a serial port.

        Parameters
        ----------
        port : str
            OS-specific port name or ``'Virtual Smoothie'``
        options : dict
            if :attr:`port` is set to ``'Virtual Smoothie'``, provide
            the list of options to be passed to :func:`get_virtual_device`

        Returns
        -------
        ``True`` for success, ``False`` for failure.

        Note
        ----
        If you wish to connect to the robot without using the OT App, you will
        need to use this function.

        Examples
        --------

        >>> from opentrons import robot # doctest: +SKIP
        >>> robot.connect() # doctest: +SKIP
        """

        self._driver.connect(port=port)
        self.fw_version = self._driver.get_fw_version()

        # the below call to `cache_instrument_models` is relied upon by
        # `Session._simulate()`, which calls `robot.connect()` after exec'ing a
        # protocol. That protocol could very well have different pipettes than
        # what are physically attached to the robot
        self.cache_instrument_models()

    def _update_axis_homed(self, *args):
        for a in args:
            for letter in a:
                if letter.lower() in self.axis_homed:
                    self.axis_homed[letter.lower()] = True

    def home(self, *args, **kwargs):
        """
        Home robot's head and plunger motors.
        """

        # Home gantry first to avoid colliding with labware
        # and to make sure tips are not in the liquid while
        # homing plungers. Z/A axis will automatically home before X/Y
        self.poses = self.gantry.home(self.poses)

        # Then plungers. If we have a loaded instrument, use it to home since
        # that will use the correct current.
        for mount in ['left', 'right']:
            actuator = self._actuators[mount]['plunger']
            actuator.set_active_current(
                self.model_by_mount[mount]['home_current'])
            self.poses = actuator.home(self.poses)

        # next move should not use any previously used instrument or labware
        # to prevent robot.move_to() from using risky path optimization
        self._previous_instrument = None
        self._prev_container = None

        # explicitly update carriage Mover positions in pose tree
        # because their Mover.home() commands aren't used here
        for a in self._actuators.values():
            self.poses = a['carriage'].update_pose_from_driver(self.poses)

    def home_z(self):
        for mount in ['left', 'right']:
            self.poses = self._actuators[mount]['carriage'].home(self.poses)

    def move_head(self, *args, **kwargs):
        self.poses = self.gantry.move(self.poses, **kwargs)

    def head_speed(
            self, combined_speed=None,
            x=None, y=None, z=None, a=None, b=None, c=None):
        """
        Set the speeds (mm/sec) of the robot

        Parameters
        ----------
        combined_speed : number specifying a combined-axes speed
        <axis> : key/value pair, specifying the maximum speed of that axis

        Examples
        ---------

        >>> from opentrons import robot # doctest: +SKIP
        >>> robot.reset() # doctest: +SKIP
        >>> robot.head_speed(combined_speed=400) # doctest: +SKIP
        #  sets the head speed to 400 mm/sec or the axis max per axis
        >>> robot.head_speed(x=400, y=200) # doctest: +SKIP
        # sets max speeds of X and Y
        """
        user_set_speeds = {'x': x, 'y': y, 'z': z, 'a': a, 'b': b, 'c': c}
        axis_max_speeds = {
            axis: value
            for axis, value in user_set_speeds.items()
            if value
        }
        if axis_max_speeds:
            self._driver.set_axis_max_speed(axis_max_speeds)
        if combined_speed:
            self._driver.set_speed(combined_speed)

    def move_to(
            self,
            location,
            instrument,
            strategy='arc',
            **kwargs):
        """
        Move an instrument to a coordinate, container or a coordinate within
        a container.

        Parameters
        ----------
        location : one of the following:
            1. :class:`Placeable` (i.e. Container, Deck, Slot, Well) — will
            move to the origin of a container.
            2. :class:`Vector` move to the given coordinate in Deck coordinate
            system.
            3. (:class:`Placeable`, :class:`Vector`) move to a given coordinate
            within object's coordinate system.

        instrument :
            Instrument to move relative to. If ``None``, move relative to the
            center of a gantry.

        strategy : {'arc', 'direct'}
            ``arc`` : move to the point using arc trajectory
            avoiding obstacles.

            ``direct`` : move to the point in a straight line.
        """

        placeable, coordinates = containers.unpack_location(location)

        # because the top position is what is tracked,
        # this checks if coordinates doesn't equal top
        offset = subtract(coordinates, placeable.top()[1])

        if isinstance(placeable, containers.WellSeries):
            placeable = placeable[0]

        target = add(
            pose_tracker.absolute(
                self.poses,
                placeable
            ),
            offset.coordinates
        )

        if self._previous_instrument:
            if self._previous_instrument != instrument:
                self._previous_instrument.retract()
                # because we're switching pipettes, this ensures a large (safe)
                # Z arc height will be used for the new pipette
                self._prev_container = None

        self._previous_instrument = instrument

        if strategy == 'arc':
            arc_coords = self._create_arc(instrument, target, placeable)
            for coord in arc_coords:
                self.poses = instrument._move(
                    self.poses,
                    **coord)

        elif strategy == 'direct':
            position = {'x': target[0], 'y': target[1], 'z': target[2]}
            self.poses = instrument._move(
                self.poses,
                **position)
        else:
            raise RuntimeError(
                'Unknown move strategy: {}'.format(strategy))

    def _create_arc(self, inst, destination, placeable=None):
        """
        Returns a list of coordinates to arrive to the destination coordinate
        """
        this_container = None
        if isinstance(placeable, containers.Well):
            this_container = placeable.get_parent()
        elif isinstance(placeable, containers.WellSeries):
            this_container = placeable.get_parent()
        elif isinstance(placeable, containers.Container):
            this_container = placeable

        if this_container and self._prev_container == this_container:
            # movements that stay within the same container do not need to
            # avoid other containers on the deck, so the travel height of
            # arced movements can be relative to just that one container
            arc_top = self.max_placeable_height_on_deck(this_container)
            arc_top += TIP_CLEARANCE_LABWARE
        elif self._use_safest_height:
            # bring the pipettes up as high as possible while calibrating
            arc_top = inst._max_deck_height()
        else:
            # bring pipette up above the tallest container currently on deck
            arc_top = self.max_deck_height() + TIP_CLEARANCE_DECK

        self._prev_container = this_container

        # if instrument is currently taller than arc_top, don't move down
        _, _, pip_z = pose_tracker.absolute(self.poses, inst)

        arc_top = max(arc_top, destination[2], pip_z)
        arc_top = min(arc_top, inst._max_deck_height())

        strategy = [
            {'z': arc_top},
            {'x': destination[0], 'y': destination[1]},
            {'z': destination[2]}
        ]

        return strategy

    def disconnect(self):
        """
        Disconnects from the robot.
        """
        if self._driver:
            self._driver.disconnect()

        self.axis_homed = {
            'x': False, 'y': False, 'z': False, 'a': False, 'b': False}

    def get_deck_slot_types(self):
        return 'slots'

    def get_slot_offsets(self):
        """
        col_offset
        - from bottom left corner of 1 to bottom corner of 2

        row_offset
        - from bottom left corner of 1 to bottom corner of 4

        TODO: figure out actual X and Y offsets (from origin)
        """
        SLOT_OFFSETS = {
            'slots': {
                'col_offset': 132.50,
                'row_offset': 90.5
            }
        }
        slot_settings = SLOT_OFFSETS.get(self.get_deck_slot_types())
        row_offset = slot_settings.get('row_offset')
        col_offset = slot_settings.get('col_offset')
        return (row_offset, col_offset)

    def get_max_robot_rows(self):
        # TODO: dynamically figure out robot rows
        return 4

    def get_max_robot_cols(self):
        # TODO: dynamically figure out robot cols
        return 3

    def add_slots_to_deck(self):
        row_offset, col_offset = self.get_slot_offsets()
        row_count = self.get_max_robot_rows()
        col_count = self.get_max_robot_cols()

        for row_index in range(row_count):
            for col_index in range(col_count):
                properties = {
                    'width': col_offset,
                    'length': row_offset,
                    'height': 0
                }
                slot = containers.Slot(properties=properties)
                slot_coordinates = (
                    (col_offset * col_index),
                    (row_offset * row_index),
                    0
                )
                slot_index = col_index + (row_index * col_count)
                slot_name = str(slot_index + 1)
                self._deck.add(slot, slot_name, slot_coordinates)

    def setup_deck(self):
        self.add_slots_to_deck()

        # Setup Deck as root object for pose tracker
        self.poses = pose_tracker.add(
            self.poses,
            self._deck
        )

        for slot in self._deck:
            self.poses = pose_tracker.add(
                self.poses,
                slot,
                self._deck,
                pose_tracker.Point(*slot._coordinates)
            )

        # @TODO (Laura & Andy) Slot and type of trash
        # needs to be pulled from config file
        if fflags.short_fixed_trash():
            self._fixed_trash = self.add_container(
                'opentrons_1_trash_850ml_fixed', '12')
        else:
            self._fixed_trash = self.add_container(
                'opentrons_1_trash_1100ml_fixed', '12')

    @property
    def deck(self):
        return self._deck

    @property
    def fixed_trash(self):
        return self._fixed_trash

    def get_instruments_by_name(self, name):
        res = []
        for k, v in self.get_instruments():
            if v.name == name:
                res.append((k, v))

        return res

    def get_instruments(self, name=None):
        """
        :returns: sorted list of (mount, instrument)
        """
        if name:
            return self.get_instruments_by_name(name)

        return sorted(
            self._instruments.items(), key=lambda s: s[0].lower())

    def get_containers(self):
        """
        Returns all containers currently on the deck.
        """
        return self._deck.containers()

    def add_container_by_definition(
            self, definition, slot, label=None, share=False):
        container = load_new_labware_def(definition)
        container_patched = _setup_container(container)
        return self._add_container_obj(
            container_patched, container_patched.properties['type'],
            slot, label, share)

    def add_container(self, name, slot, label=None, share=False, version=None):
        container = _load_container_by_name(name, version=version)
        container_patched = _setup_container(container)
        if not container_patched:
            return None
        else:
            return self._add_container_obj(
                container_patched, name, slot, label, share)

    def _add_container_obj(
            self, container, name, slot, label=None, share=False):
        location = self._get_placement_location(slot)
        if self._is_available_slot(location, share, slot, name):
            location.add(container, label or name, original_name=name)
        self.add_container_to_pose_tracker(location, container)
        self.max_deck_height.cache_clear()
        return container

    def add_container_to_pose_tracker(self, location, container: Container):
        """
        Add container and child wells to pose tracker. Sets container.parent
        (slot) as pose tracker parent
        """
        self.poses = pose_tracker.add(
            self.poses,
            container,
            container.parent,
            pose_tracker.Point(*container._coordinates))

        for well in container:
            center_x, center_y, center_z = well.top()[1]
            offset_x, offset_y, offset_z = well._coordinates
            center_z = 0
            self.poses = pose_tracker.add(
                self.poses,
                well,
                container,
                pose_tracker.Point(
                    center_x + offset_x,
                    center_y + offset_y,
                    center_z + offset_z
                )
            )

    @commands.publish.both(command=commands.pause)
    def pause(self, msg=None):
        """
        Pauses execution of the protocol. Use :meth:`resume` to resume
        """
        self.execute_pause()

    def execute_pause(self):
        """ Pause the driver

        This method should not be called inside a protocol. Use
        :py:meth:`pause` instead
        """
        self._driver.pause()

    @commands.publish.both(command=commands.resume)
    def resume(self):
        """
        Resume execution of the protocol after :meth:`pause`
        """
        self.execute_resume()

    def execute_resume(self):
        """ Resume the driver after :meth:`execute_pause`

        This method should not be called inside a protocol. Use
        :py:meth:`resume` instead
        """
        self._driver.resume()

    def stop(self):
        """
        Stops execution of the protocol. (alias for `halt`)
        """
        self._driver.kill()
        self.reset()
        self.home()

    def halt(self):
        """
        Stops execution of both the protocol and the Smoothie board immediately
        """
        self._driver.hard_halt()

    def get_attached_pipettes(self):
        """
        Gets model names of attached pipettes

        :return: :dict with keys 'left' and 'right' and a model string for each
            mount, or 'uncommissioned' if no model string available
        """
        left_data = {
                'mount_axis': 'z',
                'plunger_axis': 'b',
                'model': self.model_by_mount['left']['model'],
                'name': self.model_by_mount['left']['name'],
                'id': self.model_by_mount['left']['id']
            }
        left_model = left_data.get('model')

        if left_model:
            tip_length = pipette_config.load(
                left_model, left_data['id']).tip_length
            left_data.update({'tip_length': tip_length})

        right_data = {
                'mount_axis': 'a',
                'plunger_axis': 'c',
                'model': self.model_by_mount['right']['model'],
                'name': self.model_by_mount['right']['name'],
                'id': self.model_by_mount['right']['id']
            }
        right_model = right_data.get('model')
        if right_model:
            tip_length = pipette_config.load(
                right_model, right_data['id']).tip_length
            right_data.update({'tip_length': tip_length})
        return {
            'left': left_data,
            'right': right_data
        }

    def get_serial_ports_list(self):
        ports = []
        # TODO: Store these settings in config
        if os.environ.get('ENABLE_VIRTUAL_SMOOTHIE', '').lower() == 'true':
            ports = [drivers.VIRTUAL_SMOOTHIE_PORT]
        ports.extend(drivers.get_serial_ports_list())
        return ports

    def is_connected(self):
        if not self._driver:
            return False
        return self._driver.is_connected()

    def is_simulating(self):
        if not self._driver:
            return False
        return self._driver.simulating

    @commands.publish.both(command=commands.comment)
    def comment(self, msg):
        pass

    def commands(self):
        return self._commands

    def clear_commands(self):
        self._commands.clear()
        if self._unsubscribe_commands:
            self._unsubscribe_commands()

        def on_command(message):
            payload = message.get('payload')
            text = payload.get('text')
            if text is None:
                return

            if message['$'] == 'before':
                self._commands.append(text.format(**payload))

        self._unsubscribe_commands = self.broker.subscribe(
            commands.types.COMMAND, on_command)

    def calibrate_container_with_instrument(self,
                                            container: Container,
                                            instrument,
                                            save: bool
                                            ):
        '''Calibrates a container using the top or bottom of the first well'''
        well = container[0]

        # Get the relative position of well with respect to instrument
        delta = pose_tracker.change_base(
            self.poses,
            src=instrument,
            dst=well
        )

        if fflags.calibrate_to_bottom():

            delta_x = delta[0]
            delta_y = delta[1]
            if 'tiprack' in container.get_type():
                delta_z = delta[2]
            else:
                delta_z = delta[2] + well.z_size()
        else:
            delta_x = delta[0]
            delta_y = delta[1]
            delta_z = delta[2]

        self.poses = self._calibrate_container_with_delta(
            self.poses,
            container,
            delta_x,
            delta_y,
            delta_z,
            save
        )

        self.max_deck_height.cache_clear()

    @staticmethod
    def _calibrate_container_with_delta(
            pose_tree, container, delta_x,
            delta_y, delta_z, save, new_container_name=None):

        delta = pose_tracker.Point(delta_x, delta_y, delta_z)

        # Note: pose tree is updated here, in order to update in-memory state.
        # Separately from that, on-disk state is updated. This is a point of
        # possible dis-unity. Would probably work better to un-load the labware
        # after calibration, and then reload it (would have to figure out where
        # in the call-stack this could be done without raising exceptions due
        # to trying to access old references).

        # Have to update all of the things in the pose tree that have the same
        # load name, otherwise you end up getting the calibration values
        # added together in the on-disk representation
        target_name = container.get_name()
        matching_entries = [
            x for x in list(pose_tree.keys())
            if type(x) == Container and x.get_name() == target_name]
        for entry in matching_entries:
            old_coordinates = pose_tracker.change_base(
                pose_tree,
                src=entry,
                dst=entry.parent)
            new_coordinates = old_coordinates + delta

            pose_tree = pose_tracker.update(
                pose_tree, entry, new_coordinates)
            entry._coordinates = entry._coordinates + delta

        if save and container.properties.get('labware_hash'):
            save_new_offsets(container.properties['labware_hash'], delta)
        elif save and new_container_name:
            database.save_new_container(container, new_container_name)
        elif save:
            database.overwrite_container(container)
        return pose_tree

    @lru_cache()
    def max_deck_height(self):
        return pose_tracker.max_z(self.poses, self._deck)

    def max_placeable_height_on_deck(self, placeable):
        """
        :param placeable:
        :return: Calibrated height of container in mm from
        deck as the reference point
        """
        offset = placeable.top()[1]
        placeable_coordinate = add(
            pose_tracker.absolute(
                self.poses,
                placeable
            ),
            offset.coordinates
        )
        placeable_tallest_point = pose_tracker.max_z(self.poses, placeable)
        return placeable_coordinate[2] + placeable_tallest_point

    def update_config(self, **kwargs):
        """ Replace configuration values.

        kwargs should contain configuration keys. For instance:
        `robot.update_config(name='Grace Hopper')` will update the `name` key
        of the configuration.
        """
        # Deck CLI tool needs to update the pose_tracker in real time to
        # successfully save tip probe center. Here, update the position
        # with freshly determined deck transform.

        if 'gantry_calibration' in kwargs:
            self.poses = pose_tracker.update(
                self.poses,
                self._gantry_cal_id,
                point=pose_tracker.Point(0, 0, 0),
                transform=array(kwargs['gantry_calibration']))
        self.config = self.config._replace(**kwargs)

    def set_config(self, config):
        """ Replace the entire configuration. """
        self.config = config

    async def update_firmware(self,
                              filename,
                              loop=None,
                              explicit_modeset=True):
        if self.is_simulating():
            return
        if loop is None:
            checked_loop = asyncio.get_event_loop()
        else:
            checked_loop = loop
        msg = await self._driver.update_firmware(
            filename, checked_loop, explicit_modeset)
        self.fw_version = self._driver.get_fw_version()
        self.connect()
        return msg

    @property
    def engaged_axes(self):
        """ Which axes are engaged and holding. """
        return self._driver.engaged_axes

    async def disengage_axes(self, axes):
        self._driver.disengage_axis(''.join(axes))

    @property
    def attached_modules(self):
        return self._attached_modules

    def discover_modules(self):
        discovered = {port + model: (port, model)
                      for port, model in modules.discover()}
        these = set(discovered.keys())
        known = set(self._attached_modules.keys())
        new = these - known
        gone = known - these
        for mod in gone:
            log.info(f"Module {mod} disconnected")
            self._attached_modules.pop(mod)
        for mod in new:
            module_class = modules.SUPPORTED_MODULES[discovered[mod][1]]
            port = discovered[mod][0]
            self._attached_modules[mod]\
                = module_class(port=port, broker=self.broker)

            try:
                self._attached_modules[mod].connect()
            except AttributeError:
                log.exception('Failed to connect module')
            else:
                log.info(f"Module {mod} discovered and connected")
