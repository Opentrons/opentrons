"""Protocol run control and management."""
from dataclasses import dataclass
from typing import List, Optional

from opentrons.hardware_control import HardwareControlAPI
from opentrons.protocol_reader import (
    ProtocolSource,
    PythonProtocolConfig,
    JsonProtocolConfig,
)
from opentrons.protocol_engine import (
    ProtocolEngine,
    Command,
    ErrorOccurrence,
    LoadedLabware,
    LoadedPipette,
)

from .task_queue import TaskQueue
from .json_file_reader import JsonFileReader
from .json_command_translator import JsonCommandTranslator
from .python_file_reader import PythonFileReader
from .python_context_creator import PythonContextCreator
from .python_executor import PythonExecutor
from .legacy_context_plugin import LegacyContextPlugin
from .legacy_labware_offset_provider import LegacyLabwareOffsetProvider
from .legacy_wrappers import (
    LEGACY_PYTHON_API_VERSION_CUTOFF,
    LEGACY_JSON_SCHEMA_VERSION_CUTOFF,
    LegacyFileReader,
    LegacyContextCreator,
    LegacyExecutor,
)


@dataclass(frozen=True)
class ProtocolRunData:
    """Data from a protocol run."""

    commands: List[Command]
    errors: List[ErrorOccurrence]
    labware: List[LoadedLabware]
    pipettes: List[LoadedPipette]


# TODO(mc, 2022-01-11): this class has become bloated. Split into an abstract
# interfaces and several concrete implementations per protocol type
class ProtocolRunner:
    """An interface to manage and control a protocol run.

    The ProtocolRunner is primarily responsible for feeding a ProtocolEngine
    with commands and control signals. These commands and signals are
    generated by protocol files, hardware signals, or externally via
    the HTTP robot-server.

    A ProtocolRunner controls a single run. Once the run is finished,
    you will need a new ProtocolRunner to do another run.
    """

    def __init__(
        self,
        protocol_engine: ProtocolEngine,
        hardware_api: HardwareControlAPI,
        task_queue: Optional[TaskQueue] = None,
        json_file_reader: Optional[JsonFileReader] = None,
        json_command_translator: Optional[JsonCommandTranslator] = None,
        python_file_reader: Optional[PythonFileReader] = None,
        python_context_creator: Optional[PythonContextCreator] = None,
        python_executor: Optional[PythonExecutor] = None,
        legacy_file_reader: Optional[LegacyFileReader] = None,
        legacy_context_creator: Optional[LegacyContextCreator] = None,
        legacy_executor: Optional[LegacyExecutor] = None,
    ) -> None:
        """Initialize the ProtocolRunner with its dependencies."""
        self._protocol_engine = protocol_engine
        self._hardware_api = hardware_api
        self._json_file_reader = json_file_reader or JsonFileReader()
        self._json_command_translator = (
            json_command_translator or JsonCommandTranslator()
        )
        self._python_file_reader = python_file_reader or PythonFileReader()
        self._python_context_creator = python_context_creator or PythonContextCreator()
        self._python_executor = python_executor or PythonExecutor()
        self._legacy_file_reader = legacy_file_reader or LegacyFileReader()
        self._legacy_context_creator = legacy_context_creator or LegacyContextCreator(
            hardware_api=hardware_api,
            labware_offset_provider=LegacyLabwareOffsetProvider(
                labware_view=protocol_engine.state_view.labware,
            ),
        )
        self._legacy_executor = legacy_executor or LegacyExecutor(
            hardware_api=hardware_api
        )
        self._was_started = False
        # TODO(mc, 2022-01-11): replace task queue with specific implementations
        # of runner interface
        self._task_queue = task_queue or TaskQueue(cleanup_func=protocol_engine.finish)

    def was_started(self) -> bool:
        """Whether the runner has been started.

        This value is latched; once it is True, it will never become False.
        """
        return self._was_started

    def load(self, protocol_source: ProtocolSource) -> None:
        """Load a ProtocolSource into managed ProtocolEngine.

        Calling this method is only necessary if the runner will be used
        to control the run of a file-based protocol.
        """
        config = protocol_source.config

        for definition in protocol_source.labware_definitions:
            self._protocol_engine.add_labware_definition(definition)

        if isinstance(config, JsonProtocolConfig):
            schema_version = config.schema_version

            if schema_version >= LEGACY_JSON_SCHEMA_VERSION_CUTOFF:
                self._load_json(protocol_source)
            else:
                self._load_legacy(protocol_source)

        elif isinstance(config, PythonProtocolConfig):
            api_version = config.api_version

            if api_version >= LEGACY_PYTHON_API_VERSION_CUTOFF:
                self._load_python(protocol_source)
            else:
                self._load_legacy(protocol_source)

    def play(self) -> None:
        """Start or resume the run."""
        self._was_started = True
        self._protocol_engine.play()

    def pause(self) -> None:
        """Pause the run."""
        self._protocol_engine.pause()

    async def stop(self) -> None:
        """Stop (cancel) the run."""
        if self._was_started:
            await self._protocol_engine.stop()
        else:
            await self._protocol_engine.finish(drop_tips_and_home=False)

    async def run(
        self,
        protocol_source: Optional[ProtocolSource] = None,
    ) -> ProtocolRunData:
        """Run a given protocol to completion."""
        # TODO(mc, 2022-01-11): move load to runner creation, remove from `run`
        # currently `protocol_source` arg is only used by tests
        if protocol_source:
            self.load(protocol_source)

        self.play()
        self._task_queue.start()
        await self._task_queue.join()

        return ProtocolRunData(
            commands=self._protocol_engine.state_view.commands.get_all(),
            errors=self._protocol_engine.state_view.commands.get_all_errors(),
            labware=self._protocol_engine.state_view.labware.get_all(),
            pipettes=self._protocol_engine.state_view.pipettes.get_all(),
        )

    def _load_json(self, protocol_source: ProtocolSource) -> None:
        raise NotImplementedError("JSON schema v6 execution not yet implemented.")

    def _load_python(self, protocol_source: ProtocolSource) -> None:
        protocol = self._python_file_reader.read(protocol_source)
        context = self._python_context_creator.create(self._protocol_engine)
        self._task_queue.set_run_func(
            func=self._python_executor.execute,
            protocol=protocol,
            context=context,
        )

    def _load_legacy(
        self,
        protocol_source: ProtocolSource,
    ) -> None:
        protocol = self._legacy_file_reader.read(protocol_source)
        context = self._legacy_context_creator.create(protocol)

        self._protocol_engine.add_plugin(
            LegacyContextPlugin(
                hardware_api=self._hardware_api,
                protocol_context=context,
            )
        )

        self._task_queue.set_run_func(
            func=self._legacy_executor.execute,
            protocol=protocol,
            context=context,
        )
