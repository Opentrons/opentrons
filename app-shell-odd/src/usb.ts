import * as fs from 'fs'
import * as fsPromises from 'fs/promises'
import { join } from 'path'
import { flatten } from 'lodash'
import {
  robotMassStorageDeviceAdded,
  robotMassStorageDeviceEnumerated,
  robotMassStorageDeviceRemoved,
  sendFilePaths,
} from './actions'
import {
  ROBOT_MASS_STORAGE_DEVICE_ENUMERATED,
  ROBOT_MASS_STORAGE_DEVICE_REMOVED,
} from './constants'
import type { Dispatch, Action } from './types'

const FLEX_USB_MOUNT_DIR = '/media/'
const FLEX_USB_DEVICE_DIR = '/dev/'
const FLEX_USB_MOUNT_FILTER = /sd[a-z]+[0-9]+$/

// These are for backoff algorithm
// apply the delay from 1 sec 64 sec
const MAX_TRIES = 6
const wait = (ms: number): Promise<void> =>
  new Promise((resolve, reject) => setTimeout(resolve, ms))
const callWithRetry = async (
  fn: () => Promise<any>,
  depth: number = 0
): Promise<any> => {
  try {
    return await fn()
  } catch (e) {
    if (depth > MAX_TRIES) {
      throw e
    }
    await wait(2 ** depth * 1000)

    // eslint-disable-next-line @typescript-eslint/return-await
    return callWithRetry(fn, depth + 1)
  }
}

// These directories are generated by OSX and contain entries for all
// the files that were deleted from a mass storage device, or search index
// data
const isWeirdDirectoryAndShouldSkip = (dirName: string): boolean =>
  ['.Trashes', '.Spotlight']
    .map(keyword => dirName.includes(keyword))
    .reduce((prev, current) => prev || current, false)

const enumerateMassStorage = (path: string): Promise<string[]> => {
  return callWithRetry(() =>
    fsPromises.readdir(path).then(entries => {
      if (entries.length === 0) {
        throw new Error('No entries found, retrying...')
      }
      return entries
    })
  )
    .then(() => fsPromises.readdir(path, { withFileTypes: true }))
    .then(entries =>
      Promise.all(
        entries.map(entry =>
          entry.isDirectory() && !isWeirdDirectoryAndShouldSkip(entry.name)
            ? enumerateMassStorage(join(path, entry.name))
            : new Promise<string[]>(resolve => {
                resolve([join(path, entry.name)])
              })
        )
      )
    )
    .catch(error => {
      console.error(`Error enumerating mass storage: ${error}`)
      return []
    })
    .then(flatten)
    .then(result => {
      return result
    })
}
export function watchForMassStorage(dispatch: Dispatch): () => void {
  console.log('watching for mass storage')
  let prevDirs: string[] = []
  const handleNewlyPresent = (path: string): Promise<string> => {
    dispatch(robotMassStorageDeviceAdded(path))
    return enumerateMassStorage(path)
      .then(contents => {
        dispatch(robotMassStorageDeviceEnumerated(path, contents))
      })
      .then(() => path)
  }

  const rescan = (dispatch: Dispatch): Promise<unknown> =>
    fsPromises
      .readdir(FLEX_USB_MOUNT_DIR)
      .then(entries => {
        const sortedEntries = entries.sort()
        const newlyPresent = sortedEntries.filter(
          entry => !prevDirs.includes(entry)
        )
        const newlyAbsent = prevDirs.filter(
          entry => !sortedEntries.includes(entry)
        )
        return Promise.all([
          ...newlyAbsent.map(entry => {
            if (entry.match(FLEX_USB_MOUNT_FILTER)) {
              dispatch(
                robotMassStorageDeviceRemoved(join(FLEX_USB_MOUNT_DIR, entry))
              )
            }
            return null
          }),
          ...newlyPresent.map(entry => {
            if (entry.match(FLEX_USB_MOUNT_FILTER)) {
              return handleNewlyPresent(join(FLEX_USB_MOUNT_DIR, entry))
            }
            return null
          }),
        ])
      })
      .then(present => {
        prevDirs = present.filter((entry): entry is string => entry !== null)
      })

  const mediaWatcherCreator = (): fs.FSWatcher | null => {
    try {
      return fs.watch(
        FLEX_USB_MOUNT_DIR,
        { persistent: true },
        (event, fileName) => {
          if (!!!fileName) {
            rescan(dispatch)
            return
          }
          if (!fileName.match(FLEX_USB_MOUNT_FILTER)) {
            return
          }
          const fullPath = join(FLEX_USB_MOUNT_DIR, fileName)
          fsPromises
            .stat(fullPath)
            .then(info => {
              if (!info.isDirectory) {
                return
              }
              if (prevDirs.includes(fullPath)) {
                return
              }
              console.log(`New mass storage device ${fileName} detected`)
              prevDirs.push(fullPath)
              return handleNewlyPresent(fullPath)
            })
            .catch(() => {
              if (prevDirs.includes(fullPath)) {
                console.log(`Mass storage device at ${fileName} removed`)
                prevDirs = prevDirs.filter(entry => entry !== fullPath)
                dispatch(robotMassStorageDeviceRemoved(fullPath))
              }
            })
        }
      )
    } catch {
      return null
    }
  }

  const mediaWatcher = mediaWatcherCreator()

  const devWatcher = fs.watch(
    FLEX_USB_DEVICE_DIR,
    { persistent: true },
    (event, fileName) => {
      if (!!!fileName) return
      if (!fileName.match(FLEX_USB_MOUNT_FILTER)) return
      const fullPath = join(FLEX_USB_DEVICE_DIR, fileName)
      const mountPath = join(FLEX_USB_MOUNT_DIR, fileName)
      fsPromises.stat(fullPath).catch(() => {
        if (prevDirs.includes(mountPath)) {
          console.log(`Mass storage device at ${fileName} removed`)
          prevDirs = prevDirs.filter(entry => entry !== mountPath)
          dispatch(
            robotMassStorageDeviceRemoved(join(FLEX_USB_MOUNT_DIR, fileName))
          )
          // we don't care if this fails because it's racing the system removing
          // the mount dir in the common case
          fsPromises.unlink(mountPath).catch(() => {})
        }
      })
    }
  )

  rescan(dispatch)
  return () => {
    mediaWatcher != null && mediaWatcher.close()
    devWatcher.close()
  }
}

const getLatestMassStorageCsvFiles = (
  filePaths: string[],
  dispatch: Dispatch
): void => {
  // Note (kk:07/29/2024) get all files' last path
  // remove Resource fork that starts "._"
  // remove hidden file that starts "."
  const csvFilePaths = filePaths.filter(path => {
    const fileName = path.split('/').pop() || ''
    return (
      !fileName.startsWith('._') &&
      !fileName.startsWith('.') &&
      fileName.endsWith('.csv')
    )
  })
  dispatch(sendFilePaths(csvFilePaths))
}

export function registerDataFiles(
  dispatch: Dispatch
): (action: Action) => unknown {
  return function handleAction(action: Action) {
    switch (action.type) {
      case ROBOT_MASS_STORAGE_DEVICE_ENUMERATED: {
        getLatestMassStorageCsvFiles(action.payload.filePaths, dispatch)
        break
      }

      case ROBOT_MASS_STORAGE_DEVICE_REMOVED: {
        dispatch(sendFilePaths([]))
        break
      }

      default:
        break
    }
  }
}
