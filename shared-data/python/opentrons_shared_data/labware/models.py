"""
This was initially generated by datamodel-codegen from the labware schema in
shared-data. It's been modified by hand to be more friendly.
"""

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Literal, Union

from pydantic import (
    ConfigDict,
    BaseModel,
    Field,
)
from opentrons_shared_data.types import Vec3f, Number, NonNegativeNumber


SAFE_STRING_REGEX = "^[a-z0-9._]+$"


class CornerOffsetFromSlot(Vec3f[Number]):
    """
    Distance from left-front-bottom corner of slot to left-front-bottom corner
     of labware bounding box. Used for labware that spans multiple slots. For
      labware that does not span multiple slots, x/y/z should all be zero.
    """


class OverlapOffset(Vec3f[Number]):
    """
    Overlap dimensions of labware with another labware/module that it can be stacked on top of.
    """


class OffsetVector(Vec3f[Number]):
    """
    A generic 3-D offset vector.
    """

    def __add__(self, other: Any) -> OffsetVector:
        """Adds two vectors together."""
        if not isinstance(other, OffsetVector):
            return NotImplemented
        return OffsetVector(x=self.x + other.x, y=self.y + other.y, z=self.z + other.z)

    def __sub__(self, other: Any) -> OffsetVector:
        """Subtracts two vectors."""
        if not isinstance(other, OffsetVector):
            return NotImplemented
        return OffsetVector(x=self.x - other.x, y=self.y - other.y, z=self.z - other.z)


class GripperOffsets(BaseModel):
    """
    Offsets used when calculating coordinates for gripping labware during labware movement.
    """

    pickUpOffset: OffsetVector
    dropOffset: OffsetVector


class BrandData(BaseModel):
    brand: str = Field(..., description="Brand/manufacturer name")
    brandId: Optional[List[str]] = Field(
        None,
        description="An array of manufacture numbers pertaining to a given labware",
    )
    links: Optional[List[str]] = Field(
        None, description="URLs for manufacturer page(s)"
    )


class DisplayCategory(str, Enum):
    tipRack = "tipRack"
    tubeRack = "tubeRack"
    reservoir = "reservoir"
    trash = "trash"
    wellPlate = "wellPlate"
    aluminumBlock = "aluminumBlock"
    adapter = "adapter"
    other = "other"


class LabwareRole(str, Enum):
    labware = "labware"
    fixture = "fixture"
    adapter = "adapter"
    maintenance = "maintenance"


class Metadata(BaseModel):
    """
    Properties used for search and display
    """

    displayName: str = Field(..., description="Easy to remember name of labware")
    displayCategory: DisplayCategory = Field(
        ..., description="Label(s) used in UI to categorize labware"
    )
    displayVolumeUnits: Literal["ÂµL", "mL", "L"] = Field(
        ..., description="Volume units for display"
    )
    tags: Optional[List[str]] = Field(
        None, description="List of descriptions for a given labware"
    )


class Parameters(BaseModel):
    """
    Internal describers used to determine pipette movement to labware
    """

    format: Literal[
        "96Standard", "384Standard", "trough", "irregular", "trash"
    ] = Field(
        ..., description="Property to determine compatibility with multichannel pipette"
    )
    quirks: Optional[List[str]] = Field(
        None,
        description="Property to classify a specific behavior this labware "
        "should have",
    )
    isTiprack: bool = Field(
        ..., description="Flag marking whether a labware is a tiprack or not"
    )
    tipLength: Optional[NonNegativeNumber] = Field(
        None,
        description="Required if labware is tiprack, specifies length of tip"
        " from drawing or as measured with calipers",
    )
    tipOverlap: Optional[NonNegativeNumber] = Field(
        None,
        description="Required if labware is tiprack, specifies the length of "
        "the area of the tip that overlaps the nozzle of the pipette",
    )
    loadName: str = Field(
        ...,
        description="Name used to reference a labware definition",
        pattern=SAFE_STRING_REGEX,
    )
    isMagneticModuleCompatible: bool = Field(
        ...,
        description="Flag marking whether a labware is compatible by default "
        "with the Magnetic Module",
    )
    magneticModuleEngageHeight: Optional[NonNegativeNumber] = Field(
        None, description="Distance to move magnetic module magnets to engage"
    )


class Dimensions(BaseModel):
    """
    Outer dimensions of a labware
    """

    yDimension: NonNegativeNumber = Field(...)
    zDimension: NonNegativeNumber = Field(...)
    xDimension: NonNegativeNumber = Field(...)


class WellDefinition(BaseModel):
    model_config = ConfigDict(extra="allow")

    depth: NonNegativeNumber = Field(...)
    x: NonNegativeNumber = Field(
        ...,
        description="x location of center-bottom of well in reference to "
        "left-front-bottom of labware",
    )
    y: NonNegativeNumber = Field(
        ...,
        description="y location of center-bottom of well in reference to "
        "left-front-bottom of labware",
    )
    z: NonNegativeNumber = Field(
        ...,
        description="z location of center-bottom of well in reference to "
        "left-front-bottom of labware",
    )
    totalLiquidVolume: NonNegativeNumber = Field(
        ..., description="Total well, tube, or tip volume in microliters"
    )
    xDimension: Optional[NonNegativeNumber] = Field(
        None,
        description="x dimension of rectangular wells",
    )
    yDimension: Optional[NonNegativeNumber] = Field(
        None,
        description="y dimension of rectangular wells",
    )
    diameter: Optional[NonNegativeNumber] = Field(
        None,
        description="diameter of circular wells",
    )
    shape: Literal["rectangular", "circular"] = Field(
        ...,
        description="If 'rectangular', use xDimension and "
        "yDimension; if 'circular' use diameter",
    )
    geometryDefinitionId: Optional[str] = Field(
        None, description="str id of the well's corresponding" "innerWellGeometry"
    )


class CircularCrossSection(BaseModel):
    shape: Literal["circular"] = Field(..., description="Denote shape as circular")
    diameter: NonNegativeNumber = Field(
        ..., description="The diameter of a circular cross section of a well"
    )


class RectangularCrossSection(BaseModel):
    shape: Literal["rectangular"] = Field(
        ..., description="Denote shape as rectangular"
    )
    xDimension: Optional[NonNegativeNumber] = Field(
        None,
        description="x dimension of a subsection of wells",
    )
    yDimension: Optional[NonNegativeNumber] = Field(
        None,
        description="y dimension of a subsection of wells",
    )


class SphericalSegment(BaseModel):
    shape: Literal["spherical"] = Field(..., description="Denote shape as spherical")
    radius_of_curvature: NonNegativeNumber = Field(
        ...,
        description="radius of curvature of bottom subsection of wells",
    )
    depth: NonNegativeNumber = Field(
        ..., description="The depth of a spherical bottom of a well"
    )


TopCrossSection = Union[CircularCrossSection, RectangularCrossSection]
BottomShape = Union[CircularCrossSection, RectangularCrossSection, SphericalSegment]


class BoundedSection(BaseModel):
    geometry: TopCrossSection = Field(
        ...,
        description="Geometrical information needed to calculate the volume of a subsection of a well",
        discriminator="shape",
    )
    topHeight: NonNegativeNumber = Field(
        ...,
        description="The height at the top of a bounded subsection of a well, relative to the bottom"
        "of the well",
    )


class Metadata1(BaseModel):
    """
    Metadata specific to a grid of wells in a labware
    """

    displayName: Optional[str] = Field(
        None, description="User-readable name for the well group"
    )
    displayCategory: Optional[DisplayCategory] = Field(
        None, description="Label(s) used in UI to categorize well groups"
    )
    wellBottomShape: Optional[Literal["flat", "u", "v"]] = Field(
        None, description="Bottom shape of the well for UI purposes"
    )


class Group(BaseModel):
    wells: List[str] = Field(
        ..., description="An array of wells that contain the same metadata"
    )
    metadata: Metadata1 = Field(
        ..., description="Metadata specific to a grid of wells in a labware"
    )
    brand: Optional[BrandData] = Field(
        None, description="Brand data for the well group (e.g. for tubes)"
    )


class InnerWellGeometry(BaseModel):
    frusta: List[BoundedSection] = Field(
        ...,
        description="A list of all of the sections of the well that have a contiguous shape",
    )
    bottomShape: BottomShape = Field(
        ...,
        description="The shape at the bottom of the well: either a spherical segment or a cross-section",
        discriminator="shape",
    )


class LabwareDefinition(BaseModel):
    schemaVersion: Literal[1, 2] = Field(
        ..., description="Which schema version a labware is using"
    )
    version: int = Field(
        ...,
        description="Version of the labware definition itself "
        "(eg myPlate v1/v2/v3). An incrementing integer",
        ge=1.0,
    )
    namespace: str = Field(..., pattern=SAFE_STRING_REGEX)
    metadata: Metadata = Field(
        ..., description="Properties used for search and display"
    )
    brand: BrandData = Field(
        ...,
        description="Real-world labware that the definition is modeled "
        "from and/or compatible with",
    )
    parameters: Parameters = Field(
        ...,
        description="Internal describers used to determine pipette movement "
        "to labware",
    )
    ordering: List[List[str]] = Field(
        ...,
        description="Generated array that keeps track of how wells should be "
        "ordered in a labware",
    )
    cornerOffsetFromSlot: CornerOffsetFromSlot = Field(
        ...,
        description="Distance from left-front-bottom corner of slot to "
        "left-front-bottom corner of labware bounding box. Used for "
        "labware that spans multiple slots. For labware that does "
        "not span multiple slots, x/y/z should all be zero.",
    )
    dimensions: Dimensions = Field(..., description="Outer dimensions of a labware")
    wells: Dict[str, WellDefinition] = Field(
        ...,
        description="Unordered object of well objects with position and "
        "dimensional information",
    )
    groups: List[Group] = Field(
        ...,
        description="Logical well groupings for metadata/display purposes; "
        "changes in groups do not affect protocol execution",
    )
    allowedRoles: List[LabwareRole] = Field(
        default_factory=list,
        description="Allowed behaviors and usage of a labware in a protocol.",
    )
    stackingOffsetWithLabware: Dict[str, OverlapOffset] = Field(
        default_factory=dict,
        description="Supported labware that can be stacked upon,"
        " with overlap vector offset between both labware.",
    )
    stackingOffsetWithModule: Dict[str, OverlapOffset] = Field(
        default_factory=dict,
        description="Supported module that can be stacked upon,"
        " with overlap vector offset between labware and module.",
    )
    gripperOffsets: Dict[str, GripperOffsets] = Field(
        default_factory=dict,
        description="Offsets use when calculating coordinates for gripping labware "
        "during labware movement.",
    )
    gripHeightFromLabwareBottom: Optional[float] = Field(
        default=None,
        description="The Z-height, from labware bottom, where the gripper should grip the labware.",
    )
    gripForce: Optional[float] = Field(
        default=None,
        description="Force, in Newtons, with which the gripper should grip the labware.",
    )
    innerLabwareGeometry: Optional[Dict[str, InnerWellGeometry]] = Field(
        None,
        description="A dictionary holding all unique inner well geometries in a labware.",
    )
